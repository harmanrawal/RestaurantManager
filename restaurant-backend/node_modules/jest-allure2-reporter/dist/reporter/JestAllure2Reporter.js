"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.JestAllure2Reporter = void 0;
const tslib_1 = require("tslib");
const node_path_1 = tslib_1.__importDefault(require("node:path"));
const reporter_1 = tslib_1.__importDefault(require("jest-metadata/reporter"));
const options_1 = require("../options");
const metadata_1 = require("../metadata");
const utils_1 = require("../utils");
const serialization_1 = require("../serialization");
const logger_1 = require("../logger");
const fallbacks = tslib_1.__importStar(require("./fallbacks"));
const postProcessMetadata_1 = require("./postProcessMetadata");
const allureCommons_1 = require("./allureCommons");
const resolveTestItem_1 = require("./resolveTestItem");
const NOT_INITIALIZED = null;
const __TID = (0, logger_1.optimizeForTracing)((test) => ({
    tid: ['jest-allure2-reporter', test ? test.path : 'run'],
}));
const __TID_NAME = (0, logger_1.optimizeForTracing)((test, testCaseResult) => ({
    tid: ['jest-allure2-reporter', test.path],
    fullName: testCaseResult.fullName,
}));
class JestAllure2Reporter extends reporter_1.default {
    _globalConfig;
    _options;
    _globalContext = NOT_INITIALIZED;
    _writer = NOT_INITIALIZED;
    _config = NOT_INITIALIZED;
    _globalMetadataProxy = NOT_INITIALIZED;
    constructor(globalConfig, options) {
        super(globalConfig);
        this._globalConfig = globalConfig;
        this._options = options;
    }
    async #init() {
        this._config = await (0, options_1.resolveOptions)(this._globalConfig.rootDir, this._options);
        this._writer = new serialization_1.FileAllureWriter({
            resultsDir: this._config.resultsDir,
            overwrite: this._config.overwrite,
        });
        await this._writer.init?.();
        const testRunMetadata = _a.query.globalMetadata();
        this._globalMetadataProxy = new metadata_1.AllureMetadataProxy(testRunMetadata);
        this._globalMetadataProxy.set('config', {
            resultsDir: this._config.resultsDir,
            overwrite: this._config.overwrite,
            attachments: this._config.attachments,
            injectGlobals: this._config.injectGlobals,
        });
    }
    async #attempt(name, function_) {
        try {
            await function_.call(this);
        }
        catch (error) {
            logger_1.log.error(error, `Caught unhandled error in JestAllure2Reporter#${name}`);
        }
    }
    async #attemptSync(name, function_) {
        try {
            function_.call(this);
        }
        catch (error) {
            logger_1.log.error(error, `Caught unhandled error in JestAllure2Reporter#${name}`);
        }
    }
    async onRunStart(aggregatedResult, options) {
        await super.onRunStart(aggregatedResult, options);
        const attemptRunStart = this.#attempt.bind(this, 'onRunStart()', this.#onRunStart);
        await logger_1.log.trace.begin(__TID(), 'jest-allure2-reporter');
        await logger_1.log.trace.complete(__TID(), 'init', this.#init.bind(this));
        await logger_1.log.trace.complete(__TID(), 'onRunStart', attemptRunStart);
    }
    async #onRunStart() {
        const reporterConfig = this._config;
        const allureWriter = this._writer;
        const globalContext = {
            $: {},
            globalConfig: this._globalConfig,
            reporterConfig,
            value: undefined,
        };
        globalContext.$ = await (0, resolveTestItem_1.resolvePromisedItem)(globalContext, reporterConfig.helpers, '$');
        if (reporterConfig.sourceCode.enabled) {
            const { factories, options, plugins } = reporterConfig.sourceCode;
            const maybePlugins = await Promise.all(Object.entries(factories).map(async ([key, factory]) => factory({
                ...globalContext,
                value: options[key],
            })));
            plugins.push(...(0, utils_1.compactArray)(maybePlugins));
        }
        this._globalContext = globalContext;
        const environment = await reporterConfig.environment(globalContext);
        if (environment) {
            await allureWriter.writeEnvironmentInfo((0, utils_1.stringifyValues)(environment));
        }
        const executor = await reporterConfig.executor(globalContext);
        if (executor) {
            await allureWriter.writeExecutorInfo(executor);
        }
        const categories = await reporterConfig.categories(globalContext);
        if (categories) {
            await allureWriter.writeCategories(categories);
        }
    }
    async onTestFileStart(test) {
        super.onTestFileStart(test);
        const execute = this.#onTestFileStart.bind(this, test);
        const attempt = this.#attemptSync.bind(this, 'onTestFileStart()', execute);
        const testPath = node_path_1.default.relative(this._globalConfig.rootDir, test.path);
        logger_1.log.trace.begin(__TID(test), testPath);
        await logger_1.log.trace.complete(__TID(test), 'onTestFileStart', attempt);
    }
    async #onTestFileStart(test) {
        await utils_1.FileNavigatorCache.instance.scanSourcemap(test.path);
        const rawMetadata = _a.query.test(test);
        const testFileMetadata = new metadata_1.AllureMetadataProxy(rawMetadata);
        fallbacks.onTestFileStart(test, testFileMetadata);
    }
    async onTestCaseResult(test, testCaseResult) {
        super.onTestCaseResult(test, testCaseResult);
        const execute = this.#onTestCaseResult.bind(this, test, testCaseResult);
        const attempt = this.#attempt.bind(this, 'onTestCaseResult()', execute);
        logger_1.log.trace.complete(__TID_NAME(test, testCaseResult), testCaseResult.title, attempt);
    }
    #onTestCaseResult(test, testCaseResult) {
        const testCaseMetadata = new metadata_1.AllureMetadataProxy(_a.query.testCaseResult(testCaseResult).lastInvocation);
        fallbacks.onTestCaseResult(test, testCaseResult, testCaseMetadata);
    }
    async onTestFileResult(test, testResult, aggregatedResult) {
        await super.onTestFileResult(test, testResult, aggregatedResult);
        const execute = this.#onTestFileResult.bind(this, test, testResult);
        const attempt = this.#attempt.bind(this, 'onTestFileResult()', execute);
        await logger_1.log.trace.complete(__TID(test), 'onTestFileResult', attempt);
        logger_1.log.trace.end(__TID(test));
    }
    async #onTestFileResult(test, testResult) {
        const rawMetadata = _a.query.test(test);
        const testFileMetadata = new metadata_1.AllureMetadataProxy(rawMetadata);
        const globalMetadataProxy = this._globalMetadataProxy;
        for (const loadedFile of globalMetadataProxy.get('loadedFiles', [])) {
            await utils_1.FileNavigatorCache.instance.scanSourcemap(loadedFile);
        }
        const allureWriter = this._writer;
        fallbacks.onTestFileResult(test, testFileMetadata);
        await (0, postProcessMetadata_1.postProcessMetadata)(this._globalContext, rawMetadata);
        // ---
        const config = this._config;
        const squasher = new metadata_1.MetadataSquasher();
        const testFileContext = {
            ...this._globalContext,
            filePath: node_path_1.default.relative(this._globalConfig.rootDir, testResult.testFilePath).split(node_path_1.default.sep),
            result: {},
            testFile: testResult,
            testFileMetadata: squasher.testFile(_a.query.testResult(testResult)),
            testRunMetadata: globalMetadataProxy.get(),
            value: undefined,
        };
        const allureFileTest = await (0, resolveTestItem_1.resolvePromisedTestCase)(testFileContext, config.testFile);
        if (allureFileTest) {
            await (0, allureCommons_1.writeTest)({
                resultsDir: config.resultsDir,
                containerName: `${testResult.testFilePath}`,
                writer: allureWriter,
                test: allureFileTest,
            });
        }
        for (const testCaseResult of testResult.testResults) {
            const allInvocations = _a.query.testCaseResult(testCaseResult).invocations ?? [];
            for (const testInvocationMetadata of allInvocations) {
                const testCaseMetadata = squasher.testInvocation(testInvocationMetadata);
                const testCaseContext = {
                    ...testFileContext,
                    testCase: testCaseResult,
                    testCaseMetadata,
                };
                const allureTest = await (0, resolveTestItem_1.resolvePromisedTestCase)(testCaseContext, config.testCase);
                if (!allureTest) {
                    continue;
                }
                const invocationIndex = allInvocations.indexOf(testInvocationMetadata);
                await (0, allureCommons_1.writeTest)({
                    resultsDir: config.resultsDir,
                    containerName: `${testCaseResult.fullName} (${invocationIndex})`,
                    writer: allureWriter,
                    test: allureTest,
                });
            }
        }
    }
    async onRunComplete(testContexts, aggregatedResult) {
        await super.onRunComplete(testContexts, aggregatedResult);
        const execute = this.#onRunComplete.bind(this, aggregatedResult);
        const attempt = this.#attempt.bind(this, 'onRunComplete()', execute);
        await logger_1.log.trace.complete(__TID(), 'onRunComplete', attempt);
        await logger_1.log.trace.end(__TID());
    }
    async #onRunComplete(aggregatedResult) {
        const globalMetadataProxy = this._globalMetadataProxy;
        globalMetadataProxy.set('stop', Date.now());
        const allureWriter = this._writer;
        const config = this._config;
        const globalContext = this._globalContext;
        const testRunContext = {
            ...globalContext,
            aggregatedResult,
            result: {},
            testRunMetadata: globalMetadataProxy.get(),
            value: undefined,
        };
        const allureRunTest = await (0, resolveTestItem_1.resolvePromisedTestCase)(testRunContext, config.testRun);
        if (allureRunTest) {
            await (0, allureCommons_1.writeTest)({
                resultsDir: config.resultsDir,
                containerName: `Test Run (${process.pid})`,
                writer: allureWriter,
                test: allureRunTest,
            });
        }
        await allureWriter.cleanup?.();
    }
}
exports.JestAllure2Reporter = JestAllure2Reporter;
_a = JestAllure2Reporter;
//# sourceMappingURL=JestAllure2Reporter.js.map