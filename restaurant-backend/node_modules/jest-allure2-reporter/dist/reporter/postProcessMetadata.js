"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.postProcessMetadata = postProcessMetadata;
const metadata_1 = require("../metadata");
const logger_1 = require("../logger");
const utils_1 = require("../utils");
async function postProcessMetadata(globalContext, testFile) {
    const config = globalContext.reporterConfig;
    if (!config.sourceCode.enabled) {
        return;
    }
    const allDescribeBlocks = [...testFile.allDescribeBlocks()];
    const allHookDefinitions = allDescribeBlocks.flatMap((describeBlock) => [
        ...describeBlock.hookDefinitions(),
    ]);
    const batch = [
        testFile,
        ...allDescribeBlocks,
        ...allHookDefinitions,
        ...testFile.allTestEntries(),
        ...testFile.allTestInvocations(),
        ...testFile.allInvocations(),
    ];
    await Promise.all(batch.map(async (metadata) => {
        const allureProxy = new metadata_1.AllureMetadataProxy(metadata);
        const context = (0, utils_1.compactObject)({
            ...allureProxy.get('sourceLocation'),
            transformedCode: allureProxy.get('transformedCode'),
        });
        if (!(0, utils_1.isEmpty)(context)) {
            for (const p of config.sourceCode.plugins) {
                try {
                    const docblock = await p.extractDocblock?.(context);
                    if (docblock) {
                        allureProxy.assign({ docblock });
                        break;
                    }
                }
                catch (error) {
                    logger_1.log.warn(error, `Plugin "${p.name}" failed to extract docblock for ${context.fileName}:${context.lineNumber}:${context.columnNumber}`);
                }
            }
        }
    }));
}
//# sourceMappingURL=postProcessMetadata.js.map